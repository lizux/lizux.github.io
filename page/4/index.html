<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Personal Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Lizux">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Lizux">
<meta property="og:description" content="Personal Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="可口可乐">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Lizux</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lizux</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Just go on</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/06/06/26.jquery-angular-lodash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="可口可乐">
      <meta itemprop="description" content="Personal Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lizux">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/06/06/26.jquery-angular-lodash/" class="post-title-link" itemprop="url">对 jquery、angular、lodash 库的常见操作方法对比</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-06-06 00:00:00" itemprop="dateCreated datePublished" datetime="2016-06-06T00:00:00+08:00">2016-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-26 10:32:58" itemprop="dateModified" datetime="2023-10-26T10:32:58+08:00">2023-10-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近正在学习热门的 <code>React</code> 库，打算把一些项目从 AnglarJS 构建逐步转为 React 构建，这样的话，需要搭配的环境和运行库都有一些需要调整。</p>
<p>AnglarJS： AnglarJS + jQuery + Gulp<br>React：    React + lodash + webpack</p>
<p>由于 React 专注于 Dom 操作的效率优化，即 View 的层面，所以导致常见的数据操作方法都得自己实现或者借助第三方库，我用的是流行的 lodash 库，这样的话，就得把以前 AnglarJS 内置的方法（未内置的用 jQuery 实现）都得找到对应的 lodash 方法来完成类似功能。</p>
<p>于是有了以下对照表，以便后期查询。</p>
<table>
<thead>
<tr>
<th></th>
<th align="left">原生</th>
<th align="left">jquery</th>
<th align="left">angular</th>
<th align="left">lodash</th>
</tr>
</thead>
<tbody><tr>
<td>for 循环</td>
<td align="left">forEach(item,index)</td>
<td align="left">each(index,item)</td>
<td align="left">forEach(item,index)</td>
<td align="left">forEach(item,index)</td>
</tr>
<tr>
<td>map 循环</td>
<td align="left">map(item,index)</td>
<td align="left">map(item,index)</td>
<td align="left">map(item,index)</td>
<td align="left">map(item,index)</td>
</tr>
<tr>
<td>复制对象</td>
<td align="left">Object.assign({},target) <sup>ES6</sup><br/>{…target}<sup>babel-stage-3</sup></td>
<td align="left">extend({},target)</td>
<td align="left"></td>
<td align="left">clone()</td>
</tr>
<tr>
<td>深度复制</td>
<td align="left"></td>
<td align="left">extend(true,{},target)</td>
<td align="left">copy()</td>
<td align="left">cloneDeep()</td>
</tr>
<tr>
<td>合并对象</td>
<td align="left">Object.assign(target,o1,o2)<sup>ES6</sup><br/>{…o1, …o2}<sup>babel-stage-3</sup></td>
<td align="left">extend(target,o1,o2)</td>
<td align="left">extend(target,o1,o2)</td>
<td align="left">assign(target,o1,o2)</td>
</tr>
<tr>
<td>深度合并</td>
<td align="left"></td>
<td align="left">extend(true,target,o1,o2)</td>
<td align="left">merge(target,o1,o2)</td>
<td align="left">merge(target,o1,o2)</td>
</tr>
<tr>
<td>相等判断</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">equals(o1,o2)</td>
<td align="left">isEqual(o1,o2)</td>
</tr>
<tr>
<td>空值判断</td>
<td align="left"></td>
<td align="left">isEmptyObject()</td>
<td align="left"></td>
<td align="left">isEmpty()</td>
</tr>
<tr>
<td>类型判断</td>
<td align="left">Array.isArray()</td>
<td align="left">isArray、isNumeric、isFunction</td>
<td align="left">isArray、isNumber、isString，isDate、isFunction、isObject</td>
<td align="left">isArray、isNumber、isString，isDate、isFunction、isObject</td>
</tr>
<tr>
<td>定义判断</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">isDefined()、isUndefined()</td>
<td align="left">isUndefined()</td>
</tr>
</tbody></table>
<blockquote>
<p>注：原生的 forEach() 、map() 仅能操作数组，对象无效。<br>    对于类数组的元素可以使用 [].slice.call(obj) 对其进行转换。<br>    对于普通对象可以使用 Object.keys() 列出自有属性，然后对其操作。<br>注：jQuery 的 clone() 仅能操作 dom 元素，对象无效。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/01/11/24.angular-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="可口可乐">
      <meta itemprop="description" content="Personal Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lizux">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/01/11/24.angular-tips/" class="post-title-link" itemprop="url">AngularJS 使用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-01-11 00:00:00" itemprop="dateCreated datePublished" datetime="2016-01-11T00:00:00+08:00">2016-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-26 10:32:58" itemprop="dateModified" datetime="2023-10-26T10:32:58+08:00">2023-10-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="在控制器内访问-form-对象"><a href="#在控制器内访问-form-对象" class="headerlink" title="在控制器内访问 form 对象"></a>在控制器内访问 form 对象</h2><p>AngularJS 内置了对 form 对象的支持，可以在视图中方便对 form 进行操作，只需要设置 form 的 name 属性即可对表单进行验证、提交等相关动作</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;someForm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span> <span class="attr">ng-model</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">ng-click</span>=<span class="string">&quot;save(someForm)&quot;</span>&gt;</span>保存<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是要在控制器或子级域中访问 form 对象，就无法像视图中直接用上述方法了，需要做适当修改<br>改造后：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;forms.someForm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span> <span class="attr">ng-model</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">ng-click</span>=<span class="string">&quot;save(forms.someForm)&quot;</span>&gt;</span>保存<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$scope.<span class="property">forms</span> = &#123;&#125;;</span><br><span class="line"><span class="comment">// 控制器初始化时无法访问 form 对象，需要监听</span></span><br><span class="line">$scope.$watch(<span class="string">&#x27;forms.someForm&#x27;</span>, <span class="keyword">function</span>(<span class="params">form</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(form) &#123;</span><br><span class="line">        <span class="comment">// your code...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 延后操作时 form 对象已经准备好，没有这个问题</span></span><br><span class="line">$scope.<span class="title function_">save</span>($scope.<span class="property">forms</span>.<span class="property">someForm</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="IE-不支持-style-属性中书写-angular-表达式的问题"><a href="#IE-不支持-style-属性中书写-angular-表达式的问题" class="headerlink" title="IE 不支持 style 属性中书写 angular 表达式的问题"></a>IE 不支持 style 属性中书写 angular 表达式的问题</h2><p>如下表达式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style=&quot;width:&#123;&#123;progress&#125;&#125;%&quot;</span><br></pre></td></tr></table></figure>
<p>在 Firefox、Chrome 中正常，在 IE 中无法正确显示。</p>
<p>这是由于 IE 加载 HTML 代码时，认为 style 属性值是非法的，所以忽略并移除了它，从而导致 angularjs 无法正确计算并更新。<br>解决方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng-style=&quot;&#123;width: progress + &#x27;%&#x27;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng-attr-style=&quot;width: &#123;&#123;value&#125;&#125;%&quot;</span><br></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener" href="https://github.com/angular/angular.js/issues/2186">github</a></p>
<h2 id="input-type-file-元素不支持-ng-change-指令"><a href="#input-type-file-元素不支持-ng-change-指令" class="headerlink" title="input[type&#x3D;file] 元素不支持 ng-change 指令"></a>input[type&#x3D;file] 元素不支持 ng-change 指令</h2><p>如下表达式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">ng-change</span>=<span class="string">&quot;fileNameChanged()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>是无效的</p>
<p>解决方法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">onchange</span>=<span class="string">&quot;angular.element(this).scope().fileNameChanged()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="在-angular-中判断某-id-元素是否存在"><a href="#在-angular-中判断某-id-元素是否存在" class="headerlink" title="在 angular 中判断某 id 元素是否存在"></a>在 angular 中判断某 id 元素是否存在</h2><p>因为在 angular.element 获取某 id 会返回数组，无法使用空值来进行判断，只能判断数组长度</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (angular.<span class="title function_">element</span>(<span class="string">&#x27;#elementID&#x27;</span>).<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;#elementID 存在&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2015/11/15/22.git-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="可口可乐">
      <meta itemprop="description" content="Personal Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lizux">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/11/15/22.git-tips/" class="post-title-link" itemprop="url">Git 使用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-11-15 00:00:00" itemprop="dateCreated datePublished" datetime="2015-11-15T00:00:00+08:00">2015-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-26 10:32:58" itemprop="dateModified" datetime="2023-10-26T10:32:58+08:00">2023-10-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Git-重命名远程分支名"><a href="#Git-重命名远程分支名" class="headerlink" title="Git 重命名远程分支名"></a>Git 重命名远程分支名</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -m old_branch new_branch         # Rename branch locally</span><br><span class="line">git push origin :old_branch                 # Delete the old branch</span><br><span class="line">git push --set-upstream origin new_branch   # Push the new branch, set local branch to track the new remote</span><br></pre></td></tr></table></figure>

<h2 id="删除在本地有但在远程库中已经不存在的分支"><a href="#删除在本地有但在远程库中已经不存在的分支" class="headerlink" title="删除在本地有但在远程库中已经不存在的分支"></a>删除在本地有但在远程库中已经不存在的分支</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote prune origin</span><br></pre></td></tr></table></figure>

<h2 id="Git-复制远程分支到新分支"><a href="#Git-复制远程分支到新分支" class="headerlink" title="Git 复制远程分支到新分支"></a>Git 复制远程分支到新分支</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b new_branch old_branch</span><br></pre></td></tr></table></figure>

<h2 id="取消已经-push-的行为（强制-push）"><a href="#取消已经-push-的行为（强制-push）" class="headerlink" title="取消已经 push 的行为（强制 push）"></a>取消已经 push 的行为（强制 push）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 本地仓库回退到某一版本</span><br><span class="line">git reset -hard xxxx</span><br><span class="line"></span><br><span class="line"># 强制 PUSH，此时远程分支已经恢复成指定的 commit 了</span><br><span class="line">git push origin &lt;分支名&gt; --force</span><br></pre></td></tr></table></figure>

<h2 id="忽略已经提交到-git-版本库的文件的后续追踪-仅支持文件，目录无效"><a href="#忽略已经提交到-git-版本库的文件的后续追踪-仅支持文件，目录无效" class="headerlink" title="忽略已经提交到 git 版本库的文件的后续追踪(仅支持文件，目录无效)"></a>忽略已经提交到 git 版本库的文件的后续追踪(仅支持文件，目录无效)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git update-index --assume-unchanged index.html</span><br><span class="line">git update-index --no-assume-unchanged index.html</span><br></pre></td></tr></table></figure>

<h2 id="SourceTree-切换分支后报错：No-submodule-mapping-found-for-path-‘SampleProject’-in-gitmodules"><a href="#SourceTree-切换分支后报错：No-submodule-mapping-found-for-path-‘SampleProject’-in-gitmodules" class="headerlink" title="SourceTree 切换分支后报错：No submodule mapping found for path ‘SampleProject’ in .gitmodules"></a>SourceTree 切换分支后报错：No submodule mapping found for path ‘SampleProject’ in .gitmodules</h2><p>原因是某些操作导致 SampleProject 目录下包含 .git 文件夹，所以 SourceTree 把该文件夹看作 git submodule，但是真实情况并非如此，可以用以下命令行修复：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm -r SampleProject --cached</span><br><span class="line">git commit -m &quot;clean up folders&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Git-获取和提交代码时仅操作指定子目录"><a href="#Git-获取和提交代码时仅操作指定子目录" class="headerlink" title="Git 获取和提交代码时仅操作指定子目录"></a>Git 获取和提交代码时仅操作指定子目录</h2><p>使用 sparse-checkout，这是 1.7 版本后新增的特性</p>
<ol start="0">
<li>本地创建新目录并进入 cmd 模式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add -f origin &lt;url&gt;</span><br></pre></td></tr></table></figure></li>
<li>设置 sparse-checkout 属性<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config core.sparseCheckout true</span><br></pre></td></tr></table></figure></li>
<li>进入 <code>.git/info/sparse-checkout</code> 文件，没有就创建<br>添加指定子目录名，没有引号<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;some/dir/&quot;</span><br><span class="line">&quot;another/sub/tree&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="使用-TortoiseGit-获取和提交代码时不用每次填写用户名和密码"><a href="#使用-TortoiseGit-获取和提交代码时不用每次填写用户名和密码" class="headerlink" title="使用 TortoiseGit 获取和提交代码时不用每次填写用户名和密码"></a>使用 TortoiseGit 获取和提交代码时不用每次填写用户名和密码</h2><p>进入 <code>.git/config</code> 文件，添加以下字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[credential]</span><br><span class="line">    helper = store</span><br></pre></td></tr></table></figure>
<p>然后第一次填写后就会保存下来，以后就不用填写了。</p>
<blockquote>
<p>注：明文保存在 C:\Users[username].git-credentials 文件中</p>
</blockquote>
<h2 id="在-hexo-发布时，会提示烦人信息"><a href="#在-hexo-发布时，会提示烦人信息" class="headerlink" title="在 hexo 发布时，会提示烦人信息"></a>在 hexo 发布时，会提示烦人信息</h2><p>用 hexo deploy 时，会出现提示信息 warning: LF will be replaced by CRLF，虽然不影响使用，但看起来挺乱糟糟的。<br>若想不提示，可以切换到 hexo 根目录，执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2015/11/05/21.promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="可口可乐">
      <meta itemprop="description" content="Personal Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lizux">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/11/05/21.promise/" class="post-title-link" itemprop="url">Angular 中 Promise 研究</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-11-05 00:00:00" itemprop="dateCreated datePublished" datetime="2015-11-05T00:00:00+08:00">2015-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-26 10:32:58" itemprop="dateModified" datetime="2023-10-26T10:32:58+08:00">2023-10-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Promise-介绍"><a href="#Promise-介绍" class="headerlink" title="Promise 介绍"></a>Promise 介绍</h2><p>众所周知，Javascript 语言的执行环境是 “单线程”（Single Thread）。就是一次只能执行一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务。<br>这种模式的好处是实现起来比较简单，执行环境相对单纯，容易操作；坏处是容易造成阻塞，只要有一个任务耗时很长，后面的任务都必须排队等着，很容易导致浏览器无响应（假死）。</p>
<p>为了解决这个问题，Javascript 语言在常规的同步（Synchronous）模式之外又添加了异步（Asynchronous）模式。<br>“异步模式” 和前者的区别是，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。<br>“异步模式” 非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是 Ajax 操作。在服务器端，”异步模式” 甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有 http 请求，服务器性能会急剧下降，很快就会失去响应。</p>
<p>为了实现异步编程，我们常用的方法有：<br>0. 回调函数<br>回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。</p>
<pre><code>如下代码（通过回调方式实现）：
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentProfile = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> username = <span class="string">&#x27;something&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetchServerConfig</span>(<span class="keyword">function</span>(<span class="params">serverConfig</span>) &#123;</span><br><span class="line">    <span class="title function_">fetchUserProfiles</span>(serverConfig.<span class="property">USER_PROFILES</span>, username,</span><br><span class="line">        <span class="keyword">function</span>(<span class="params">profiles</span>) &#123;</span><br><span class="line">            currentProfile = profiles.<span class="property">currentProfile</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
0. 需要多次回调的话产生大量代码缩进，可读性性和可维护性变得很差；
0. 调试困难，因为处于回调和函数之间的错误报告非常容易丢失，除非在每一个步中都显式处理错误；
0. 如果需要使用 currentProfile 对象来做一些事情，那么需要在最内层的回调中封装真正想要实现的逻辑。
</code></pre>
<ol start="0">
<li>事件监听<br>另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。<br>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以 “去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。</li>
</ol>
<p>为了避免上述方法的缺点，CommonJS 工作组提出的一种规范，就是 Promises 对象，为异步编程提供统一接口。<br>它的思想是，每一个异步任务返回一个 Promise 对象，该对象有一个 then 方法，允许指定回调函数。<br>这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。<br>而且，它还有一个额外的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，不用担心是否错过了某个事件或信号。这种方法的缺点就是编写和理解，都相对比较难。</p>
<p>上述代码按 Promise 方式改写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentProfile = <span class="title function_">fetchServerConfig</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">serverConfig</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fetchUserProfiles</span>(serverConfig.<span class="property">USER_PROFILES</span>, username);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">profiles</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> profiles.<span class="property">currentProfile</span>;</span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理所有错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="0">
<li>可以对函数进行链式调用，所以不会陷入代码缩进噩梦中；</li>
<li>在调用链的过程中，可以保证上一个函数调用完成之后才会调用下一个函数；</li>
<li>每一个 then() 调用都带有两个参数（两个都是函数）。第一个是成功之后的回调函数，第二个是出错之后的处理函数；</li>
<li>如果调用链中出现了错误，错误将会被冒泡传递到其余的错误处理函数中。所以，最终来说，所有错误都可以在任意一个回调函数中进行处理。</li>
</ol>
<h2 id="Angular-中的-Promise——-q-服务"><a href="#Angular-中的-Promise——-q-服务" class="headerlink" title="Angular 中的 Promise——$q 服务"></a>Angular 中的 Promise——$q 服务</h2><p>要在 AngularJS 中使用 Promise，要使用 AngularJS 的内置服务 $q。<br>0. $q 服务受到 <a target="_blank" rel="noopener" href="http://documentup.com/kriskowal/q/">Kris Kowal 的 Q 库</a> 的启发，相当于轻量级版。<br>0. $q 是跟 AngularJS 的 $rootScope 模板集成的，所以在 AngularJS 中执行和拒绝都很快，避免不必要的浏览器重绘（会导致 UI 闪烁）。<br>0. $q promise 是跟 AngularJS 模板引擎集成的，这意味着在视图中找到任何 Promise 都会在视图中被执行或者拒绝。</p>
<p>我们可以先使用 $q 的 defer() 方法创建一个 deferred 实例对象。<br>deferred 对象提供了三个方法，分别是 resolve()、reject()、notify()。resolve 方法将会调用 promise 的 success 处理函数，而 reject 方法将会调用 promise 的错误处理函数。<br>然后通过 deferred 对象的 promise 属性，可以访问相关联的 promise 对象。该对象有 then() 方法可以用来链式调用回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deferred = $q.<span class="title function_">defer</span>();</span><br><span class="line"><span class="keyword">var</span> promise = deferred.<span class="property">promise</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过使用 then 方法来进行链式调用，这样做的好处是，无论前一个任务或者说 then 函数是被执行或者拒绝了都不会影响后面的 then 函数的运行。</span></span><br><span class="line">$scope.<span class="property">flag</span> = <span class="literal">true</span>;</span><br><span class="line">promise</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">        result = result + <span class="string">&#x27;pass 1 &#x27;</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">        result = result + <span class="string">&#x27;pass 2 &#x27;</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">        $scope.<span class="property">status</span> = result;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    &#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">        $scope.<span class="property">status</span> = error;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">if</span> ($scope.<span class="property">flag</span>) &#123;</span><br><span class="line">    deferred.<span class="title function_">resolve</span>(<span class="string">&#x27;ok &#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    deferred.<span class="title function_">reject</span>(<span class="string">&#x27;sorry &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 对于长耗时的处理 (比如上传，长计算，批处理，等等)，可以用 deferred.notify() 作为 then() 第三个参数，给 promise 一个监听来更新状态。</span></span><br><span class="line">promise</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">success</span>(<span class="params">data</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">error</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">notification</span>(<span class="params">notification</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">info</span>(notification);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> progress = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> interval = $interval(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (progress &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">        $interval.<span class="title function_">cancel</span>(interval);</span><br><span class="line">        deferred.<span class="title function_">resolve</span>(<span class="string">&#x27;All done!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    progress += <span class="number">10</span>;</span><br><span class="line">    deferred.<span class="title function_">notify</span>(progress + <span class="string">&#x27;%...&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise 链会把上一个 then 的返回结果传递给调用链的下一个 then (如果没有就是 undefined)</span></span><br><span class="line"><span class="comment">// 如果 then 回调返回一个 promise 对象，下一个 then 只会在这个 promise 被处理结束的时候调用。</span></span><br><span class="line"><span class="comment">// 在链最后的 catch 为整个链式处理提供一个异常处理点</span></span><br><span class="line"><span class="comment">// 在链最后的 finally 总是会被执行，不管 promise 被处理或者被拒绝，起清理作用</span></span><br><span class="line">$timeout(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    deferred.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">one</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise one resolved with &#x27;</span>, one);</span><br><span class="line">        <span class="keyword">var</span> anotherDeferred = $q.<span class="title function_">defer</span>();</span><br><span class="line">        <span class="comment">// resolve after another second</span></span><br><span class="line">        $timeout(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            anotherDeferred.<span class="title function_">resolve</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> anotherDeferred.<span class="property">promise</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">two</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise two resolved with &#x27;</span>, two);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>


<h2 id="http-中的-Promise"><a href="#http-中的-Promise" class="headerlink" title="$http 中的 Promise"></a>$http 中的 Promise</h2><p>$http 服务内建了 promise 支持，当使用标准 then() 方法设置回调函数时，会返回 promise 对象。<br>另外还有两个快捷方法 success() 和 error() ，并不会返回 promise 对象，目前官方已经不推荐使用</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2015/10/30/20.gulp-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="可口可乐">
      <meta itemprop="description" content="Personal Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lizux">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/10/30/20.gulp-tips/" class="post-title-link" itemprop="url">Gulp 使用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-10-30 00:00:00" itemprop="dateCreated datePublished" datetime="2015-10-30T00:00:00+08:00">2015-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-26 10:32:58" itemprop="dateModified" datetime="2023-10-26T10:32:58+08:00">2023-10-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="使用-npm-安装组件包时，由于被墙导致失败"><a href="#使用-npm-安装组件包时，由于被墙导致失败" class="headerlink" title="使用 npm 安装组件包时，由于被墙导致失败"></a>使用 npm 安装组件包时，由于被墙导致失败</h2><p>解决方法：<br>0. 如果用了 Goagent, 可以设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set proxy http://127.0.0.1:8087</span><br></pre></td></tr></table></figure>
<ol start="0">
<li>关闭 npm 的 https<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set strict-ssl false</span><br></pre></td></tr></table></figure>
并设置 npm 的获取地址<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry &quot;http://registry.npmjs.org/&quot;</span><br></pre></td></tr></table></figure></li>
<li>最原始的方法是自己下载该压缩包，然后保存在安装时候访问的临时文件目录下，npm install 时，如果该文件已经存在则会显示 Download already available at ***，然后直接安装。</li>
</ol>
<h2 id="使用-npm-安装组件包时，由于使用了代理，导致出现-UNABLE-TO-VERIFY-LEAF-SIGNATURE-错误"><a href="#使用-npm-安装组件包时，由于使用了代理，导致出现-UNABLE-TO-VERIFY-LEAF-SIGNATURE-错误" class="headerlink" title="使用 npm 安装组件包时，由于使用了代理，导致出现 UNABLE_TO_VERIFY_LEAF_SIGNATURE 错误"></a>使用 npm 安装组件包时，由于使用了代理，导致出现 UNABLE_TO_VERIFY_LEAF_SIGNATURE 错误</h2><p>解决方法：<br>这是因为使用了 Goagent 代理，然后请求网站根证书签名没有经过验证所致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm set strict-ssl false</span><br></pre></td></tr></table></figure>
<p>然后就可以解决问题了。<br>但是这只是临时解决方法，为了安全计，安装完成后。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set strict-ssl true</span><br></pre></td></tr></table></figure>
<p>恢复原来设置。</p>
<h2 id="npm-安装的组件包后，在-Windows-下删除该组件包，因路径名称过长，失败"><a href="#npm-安装的组件包后，在-Windows-下删除该组件包，因路径名称过长，失败" class="headerlink" title="npm 安装的组件包后，在 Windows 下删除该组件包，因路径名称过长，失败"></a>npm 安装的组件包后，在 Windows 下删除该组件包，因路径名称过长，失败</h2><p>解决方法：<br>安装一个 wdr 组件（rimraf 也可以）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g wdr</span><br><span class="line">wdr &quot;C:\folder to delete&quot;</span><br></pre></td></tr></table></figure>


<h2 id="使用-Gulp-压缩合并文件时，由于-echarts-all-脚本含有中文字符，导致-uglify-脚本时，耗时过长（7-分钟左右）"><a href="#使用-Gulp-压缩合并文件时，由于-echarts-all-脚本含有中文字符，导致-uglify-脚本时，耗时过长（7-分钟左右）" class="headerlink" title="使用 Gulp 压缩合并文件时，由于 echarts-all 脚本含有中文字符，导致 uglify 脚本时，耗时过长（7 分钟左右）"></a>使用 Gulp 压缩合并文件时，由于 echarts-all 脚本含有中文字符，导致 uglify 脚本时，耗时过长（7 分钟左右）</h2><p>解决方法：<br>指定不处理该脚本：<code>gulp.src([&#39;js/**/*.js&#39;, &#39;!echarts-all.js&#39;])</code><br>我使用的是 Yeoman 的 <code>generator-gulp-webapp</code> 生成器，所以具体到本例就是修改目录下 gulpfile.babel.js 文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释掉原本的压缩代码任务</span></span><br><span class="line"><span class="comment">//.pipe($.if(&#x27;*.js&#x27;, $.uglify()))</span></span><br><span class="line"><span class="comment">// 整个打包任务结束后，再运行自定义压缩任务</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;script&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.<span class="title function_">src</span>([<span class="string">&#x27;dist/scripts/*.js&#x27;</span>, <span class="string">&#x27;!dist/scripts/plugins.js&#x27;</span>])</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">uglify</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;dist/scripts&#x27;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="使用-Gulp-browserSync-启动-Web-服务时，支持反向代理访问-API-接口"><a href="#使用-Gulp-browserSync-启动-Web-服务时，支持反向代理访问-API-接口" class="headerlink" title="使用 Gulp + browserSync 启动 Web 服务时，支持反向代理访问 API 接口"></a>使用 Gulp + browserSync 启动 Web 服务时，支持反向代理访问 API 接口</h2><p>解决方法：<br>0. 首先安装 proxy-middleware 组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install url proxy-middleware --save-dev</span><br></pre></td></tr></table></figure>
<ol start="0">
<li>其次配置 gulpfile.babel.js 文件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;proxy-middleware&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> proxyOptions = url.<span class="title function_">parse</span>(<span class="string">&#x27;http://127.0.0.1:8080&#x27;</span>);</span><br><span class="line">proxyOptions.<span class="property">route</span> = <span class="string">&#x27;/remote-api&#x27;</span>;</span><br><span class="line"><span class="title function_">browserSync</span>(&#123;</span><br><span class="line">    <span class="attr">notify</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">9000</span>,</span><br><span class="line">    <span class="attr">server</span>: &#123;</span><br><span class="line">      <span class="attr">baseDir</span>: [<span class="string">&#x27;.tmp&#x27;</span>, <span class="string">&#x27;app&#x27;</span>],</span><br><span class="line">      <span class="attr">middleware</span>: [<span class="title function_">proxy</span>(proxyOptions)],</span><br><span class="line">      <span class="attr">routes</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;/bower_components&#x27;</span>: <span class="string">&#x27;bower_components&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2015/10/28/19.scope/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="可口可乐">
      <meta itemprop="description" content="Personal Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lizux">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/10/28/19.scope/" class="post-title-link" itemprop="url">深入理解 AngularJS 的 Scope</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-10-28 00:00:00" itemprop="dateCreated datePublished" datetime="2015-10-28T00:00:00+08:00">2015-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-26 10:32:58" itemprop="dateModified" datetime="2023-10-26T10:32:58+08:00">2023-10-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="javascript-中的原型继承"><a href="#javascript-中的原型继承" class="headerlink" title="javascript 中的原型继承"></a>javascript 中的原型继承</h2><p>在 javascript 中，有个原型继承的概念，这里就不展开篇幅深入讲述了。我们仅仅描述一下它的机制：</p>
<ul>
<li>子作用域访问一个原始类型属性时，会优先查找自身存在该属性否，不存在接着沿着原型链往上查找父作用域，直到全局作用域为止，这时还找不到就会返回 undefined。</li>
<li>子作用域对原始类型属性进行赋值时，不会查询原型链，因为原型中的属性对于子作用域来说是只读的，假如自身没有该属性就会直接创建并赋值（不会修改父作用域的同名属性）。</li>
<li>子作用域访问一个对象的属性时，会优先查找自身存在该对象否，不存在接着沿着原型链往上查找父作用域，直到全局作用域为止，这时还找不到就会返回 undefined。</li>
<li>子作用域对对象的属性进行赋值时，则会优先查找自身存在该对象否，不存在接着沿着原型链往上查找父作用域，直到全局作用域为止，这时还找不到对象就会报错，因为无法对 undefined 的属性赋值；假如找到了该对象，就会就会对其属性直接赋值，所以可以修改父作用域的对象属性。</li>
</ul>
<h2 id="AngularJS-中的原型继承"><a href="#AngularJS-中的原型继承" class="headerlink" title="AngularJS 中的原型继承"></a>AngularJS 中的原型继承</h2><p>AngularJS 中，子作用域一般都会通过 JavaScript 原型继承机制继承其父作用域的属性和方法。<br>这样，当我们对原始类型属性进行双向数据绑定时，会出现一些意想不到的问题，尤其是使用了 ng-if、ng-repeat、 ng-switch、ng-view 和 ng-include 创建了子作用域以后。因为 AngularJS 不会把数据写到你期望的父作用域属性中去，而是直接在子作用域创建同名属性并写入数据。<br>例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">&quot;OuterCtrl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;a&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">&quot;InnerCtrl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;a&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">ng-click</span>=<span class="string">&quot;a=a+1&quot;</span>&gt;</span>a++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">OuterCtrl</span>(<span class="params">$scope</span>) &#123;</span><br><span class="line">    $scope.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当点击按钮后，InnerCtrl.a 会变成 2，而 OuterCtrl.a 还是 1。<br>整个事件流程如下：没有点击按钮前，InnerCtrl 本身并没有 a 属性，它的值来自于 OuterCtrl 域，点击按钮后，由于原型继承机制的原因，此时相当于在 InnerCtrl 作用域创建了 a 属性并写入值，这就会产生困扰。</p>
<p>避免这个问题的技巧就是在 ng-model 中总使用点（.）语法，使用对象的属性来解决问题。</p>
<p>比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ng-model</span>=<span class="string">&quot;someObj.someProp&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>优于：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ng-model</span>=<span class="string">&quot;someProp&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你一定要直接使用原始类型属性，有两种办法：<br>0. 在子作用域中使用 $parent.属性名，这样可以直接修改父作用域的属性。<br>0. 在父作用域中定义函数，子作用域通过原型继承调用函数把值传递给父作用域（这种方式极少使用）。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in the parent scope</span></span><br><span class="line">$scope.<span class="property">setProp</span> = <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    $scope.<span class="property">someProp</span> = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// in the child scope</span></span><br><span class="line">$scope.<span class="title function_">setProp</span>(someValue);</span><br></pre></td></tr></table></figure></p>
<h2 id="在父scope中调用子scope的函数或方法"><a href="#在父scope中调用子scope的函数或方法" class="headerlink" title="在父scope中调用子scope的函数或方法"></a>在父scope中调用子scope的函数或方法</h2><ol start="0">
<li><p>常规方法，使用了原型继承中第4点来实现的<br> 父scope:</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$scope.<span class="property">action</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p> 子scope:</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$scope.<span class="property">action</span>.<span class="property">view</span> = <span class="keyword">function</span>(<span class="params">param</span>) &#123;</span><br><span class="line">    <span class="title function_">someFunction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以使用 $broadcast 方法<br> 父scope:</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$scope.<span class="property">action</span> = <span class="keyword">function</span>(<span class="params">param</span>) &#123;</span><br><span class="line">    $scope.$broadcast(<span class="string">&#x27;someAction&#x27;</span>, param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 子scope:</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$scope.$on(<span class="string">&#x27;someAction&#x27;</span>, <span class="keyword">function</span>(<span class="params">scope, param</span>) &#123;</span><br><span class="line">    <span class="title function_">someFunction</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2015/10/27/19.$scope-controllerAs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="可口可乐">
      <meta itemprop="description" content="Personal Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lizux">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/10/27/19.$scope-controllerAs/" class="post-title-link" itemprop="url">AngularJS 中 $scope 与 controller as 辨析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-10-27 00:00:00" itemprop="dateCreated datePublished" datetime="2015-10-27T00:00:00+08:00">2015-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-26 10:32:58" itemprop="dateModified" datetime="2023-10-26T10:32:58+08:00">2023-10-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 AngularJS 中处理 controller 时，一直使用官方默认的方式，即将 model 绑定到 $scope：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">&quot;test1Ctrl&quot;</span>&gt;</span>&#123;&#123;text&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">angular.<span class="title function_">module</span>(<span class="string">&#x27;app&#x27;</span>).<span class="title function_">controller</span>(<span class="string">&#x27;test1Ctrl&#x27;</span>, [<span class="string">&#x27;$scope&#x27;</span>, <span class="keyword">function</span>(<span class="params">$scope</span>)&#123;</span><br><span class="line">    $scope.<span class="property">text</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>

<p>AngularJS v1.2 以后，新增了一种写法，controller as，即将 model 直接绑定到 controller 的实例上：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">&quot;test2Ctrl as test&quot;</span>&gt;</span>&#123;&#123;test.text&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">angular.<span class="title function_">module</span>(<span class="string">&#x27;app&#x27;</span>).<span class="title function_">controller</span>(<span class="string">&#x27;test2Ctrl&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="variable language_">this</span>;</span><br><span class="line">    vm.<span class="property">text</span> = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> vm; <span class="comment">// 返回该实例，这样即使要改回用默认方法，也很方便直接修改第一句为 var vm = $scope 即可，后面代码不用改动</span></span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>

<p>区别：<br>0. $scope 方式，在注入时声明，后续就可以直接使用 $scope 对象；<br>   controller as 方式，在 HTML 代码里面写别名，定义 controller 不用显式的依赖 $scope，直接对 this 操作。<br>   这就变成一个普通的函数定义，即所谓的 <code>POJO（Plain Old Javascript Object）</code>，与框架无关，只有逻辑。即便不再使用 AngularJS，也可以方便快捷地剥离出来。<br>   由于不依赖 $scope，所以也就没法使用 $scope 的 <code>$watch</code>、<code>$on</code>、<code>$broadcast</code>、<code>$emit</code> 方法。<br>0. $scope 方式，$scope 中的变量和对象可以直接访问，而且也可以访问父级 scope 的变量、对象（$parentScope）；<br>   controller as 方式，this 只能访问当前的作用域，要访问父级的变量，需要通过别名。<br>0. $scope 方式，直接依赖注入 $scope 对象，直接访问；<br>   controller as 方式，别名就是定义在 $scope 上的一个对象，这就是 controller 的一个实例，在定义 controller 时绑定到 this 上的 model 其实都是绑定该实例的。这样的话，由于没有了原型链继承，有效避免了在嵌套 scope 的情况下子 scope 的属性隐藏掉父 scope 属性的情况。</p>
<p>最后，使用 $scope 或 contoller as 并没有性能上的差别，仅仅是看大家习惯罢了。</p>
<blockquote>
<p>注：无论定义 controller 时有没有直接依赖注入 $scope，DOM 中的 scope 是始终存在的。即使使用 controller as，双向绑定还是通过 $scope 的 <code>watch</code> 以及 <code>digest</code> 来实现的。<br>注：定义 route 时也能用 controller as，route 提供了一个 <code>controllerAs</code> 参数</p>
</blockquote>
<p>参考：<br><a target="_blank" rel="noopener" href="http://www.alloyteam.com/2015/04/angularjs-this-yu-scope/">AngularJS:this 与 $scope</a><br><a target="_blank" rel="noopener" href="http://pinkyjie.com/2015/02/09/controller-as-vs-scope/">用 $scope 还是用 controller as</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2015/10/26/18.angular-requirejs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="可口可乐">
      <meta itemprop="description" content="Personal Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lizux">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/10/26/18.angular-requirejs/" class="post-title-link" itemprop="url">AngularJS 是否需要 RequireJS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-10-26 00:00:00" itemprop="dateCreated datePublished" datetime="2015-10-26T00:00:00+08:00">2015-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-26 10:32:58" itemprop="dateModified" datetime="2023-10-26T10:32:58+08:00">2023-10-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一直使用 <code>AngularJS</code> 开发项目，它的模块化、依赖注入的思想很方便也很强大，代码管理起来也方便，开发完成后用 Gulp 整合打包发布到生产环境也很流畅顺利。所以就没有使用过其他方法。</p>
<p>最近接到任务研究一下模块化开发，想用 RequireJS 对项目代码组织管理一下。<br>在模块化编程领域大名鼎鼎的 <code>RequireJS</code> ，也早有耳闻，以它为代表的 AMD 规范——还有 CMD 规范（<code>SeaJS</code>）风靡 JavaScript 界。</p>
<p>我仔细研究了一下，RequireJS 此类脚本的作用无非就是解决模块化组织、代码依赖、延时按需加载等问题。</p>
<p>而在 AngularJS 里面，本事就是模块化的，它把各个功能或服务都封装成一个个独立的指令、服务、控制器、过滤器等，只暴露出一个全局 Angular 对象。<br>另外，AngularJS 使用了依赖注入的思想，可以自主加载依赖模块，而不关心具体模块的加载顺序。<br>最后，发布到生产环境的脚本一般都会用 <code>Gulp</code>、<code>Grunt</code> 等工具合并压缩成一个或少个脚本，减小 HTTP 请求数，这样的话 RequireJS 的延时按需加载也没有用武之地了。<br>这样的话，AngularJS 还需要使用 RequireJS 来管理组织代码吗？我表示深深的怀疑。<br>带着这样的疑问，搜索网络，发现一些文章也印证了我的观点。</p>
<p>参考：<br>0. <a target="_blank" rel="noopener" href="http://www.zhihu.com/question/33215340">知乎问答</a><br>0. <a target="_blank" rel="noopener" href="https://medium.com/@dickeyxxx/best-practices-for-building-angular-js-apps-266c1a4a6917">Best Practices for Building Angular.js Apps</a><br>0. <a target="_blank" rel="noopener" href="http://www.jianshu.com/p/2c93f354d909">超简单组织 AngularJS 模块</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2015/10/09/17.jquery-append/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="可口可乐">
      <meta itemprop="description" content="Personal Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lizux">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/10/09/17.jquery-append/" class="post-title-link" itemprop="url">jQuery 中 DOM 操作方法 before()、prepend()、append()、after() 的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-10-09 00:00:00" itemprop="dateCreated datePublished" datetime="2015-10-09T00:00:00+08:00">2015-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-26 10:32:58" itemprop="dateModified" datetime="2023-10-26T10:32:58+08:00">2023-10-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>jQuery 中操作 DOM 元素的方法有很多，这里统一辨析一下</p>
<ol>
<li>before&#x2F;insertBefore</li>
<li>prepend&#x2F;prependTo</li>
<li>append&#x2F;appendTo</li>
<li>after&#x2F;insertAfter</li>
<li>wrap&#x2F;unwrap</li>
</ol>
<p><code>⑤①&lt;div id=&quot;demo&quot;&gt;②content③&lt;/div&gt;④⑤</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2015/10/08/16.jquery-event-bind/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="可口可乐">
      <meta itemprop="description" content="Personal Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lizux">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/10/08/16.jquery-event-bind/" class="post-title-link" itemprop="url">jQuery 中事件绑定方法 bind()、live()、delegate()、on() 的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-10-08 00:00:00" itemprop="dateCreated datePublished" datetime="2015-10-08T00:00:00+08:00">2015-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-26 10:32:58" itemprop="dateModified" datetime="2023-10-26T10:32:58+08:00">2023-10-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>jQuery 中绑定事件的方法有三种，新版（v1.9）已经整合到 on 方法中</p>
<ul>
<li>bind(eventType [, eventData], handler(eventObject))<br>为每个匹配元素的特定事件绑定事件处理函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;a&#x27;</span>).<span class="title function_">bind</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>live(events, handler(eventObject) )<br>给所有匹配的元素附加一个事件处理函数，匹配的元素包括现在和未来。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;a&#x27;</span>).<span class="title function_">live</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>delegate(selector, eventType, handler(eventObject))<br>为所有匹配选择器的元素绑定一个或多个事件处理函数，基于一个指定的根元素的子集，匹配的元素包括现在和未来。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#container&#x27;</span>).<span class="title function_">delegate</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>on(events [, selector] [, data], handler(eventObject))<br>在选择元素上绑定一个或多个事件的事件处理函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;a&#x27;</span>).<span class="title function_">on</span>(&#123;</span><br><span class="line">    <span class="string">&#x27;click&#x27;</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;mouseenter&#x27;</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;enter&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>差别：</p>
<ul>
<li>bind() 是直接绑定在元素上</li>
<li>live() 则是通过冒泡的方式来绑定到元素上的。和 bind() 相比优势是支持动态添加元素；缺点是耗费时间，并且不支持链式操作。</li>
<li>delegate() 则是更精确的小范围使用事件代理。和 live() 相比优势是速度性、灵活性、CSS 选择支持广泛。</li>
<li>on() 则是整合了之前的三种方式，是当前推荐使用的事件绑定方法。删除绑定方法是 off()；要绑定事件，并且只运行一次，然后删除自己的方法是 one()。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">可口可乐</p>
  <div class="site-description" itemprop="description">Personal Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">可口可乐</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
